

* ascii： 发音阿斯卡

hello.c程序是以字节序列的方式存储在文件中的，每一个字符对应一个ascii编码，占用一个字节。 用8位来表示字符
ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。到目前为止共定义了128个字符
unicode 统一字符集，用32位来表示字符


* 系统32位或64位 
https://www.cnblogs.com/leijiangtao/p/4198313.html
从CPU的发展史来看,从以前的8位到现在的64位,8位也就是CPU在一个时钟周期内可并行处理8位二进字符0或是1,那么16就以此类推是64位就64位二进制.
    从数据计算上来讲理论上64位比32快一半。但因为电脑是软硬相配合才能发挥最佳性能的.所以操作系统也必须从32位的到64位的,而且系统的硬件驱动也必须是64位的.

后来推出了16位的CPU，我们就可以一次处理两个字节（16位）的数据了，比如“加1”这个命令。“加”是一个指令，占用8个位，余下的8位我们可以存放数据“1”了。
32位的CPU就更加方便了，我们就可以一次处理一个a=a+b这样的命令了。

* 指令周期、CPU周期和时钟周期
对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。而一个CPU周期是若干时钟周期之和。

* 寻址空间
一般指的是CPU对于内存寻址的能力。通俗地说，就是能最多用到多少内存
计算机的寻找范围由总线宽度（处理器的地址总线的位数）决定的，也可以理解为cpu寄存器位数，这二者一般是匹配的。

假设一台计算机,它只有1根地址线,请问它最多能对几个`存储单元`寻址?答案是：2个.因为在任何2进制计算机中,所有物理元件只有 0,1两种状态,对应这个例子,我们假设已经把这唯一的一根地址线与两个存储单元a和b连上了,那么究竟怎么确定何时读a何时读b?有一个办法,当地址线上的电压是高电压时我们读a,相反是低电压时,我们读b.如此一来,一根地址线的情况下,只能对2个存储单元进行寻址 依次类推,2根地址线时可以对4个存储单元进行寻址,对应的电压情况可以是:低低,低高,高低,高高;继续想下去,3根地址线就可以对8个存储单元进行寻址（3个1和3个0不同组合情况：111、110、100、000、101、100、001、011）,4根就是16个,也就是说,当有n根地址线时,可以对2的n次方个存储单元进行寻址。

因为字节（B）是内存的最小存储单元(最小可寻址的内存单位)，所以32根地址总线的寻址空间是 2 Byte 的32次方 = 4GB。 


* 存储单元
存储单元一般应具有存储数据和读写数据的功能，一般以8位二进制作为一个存储单元，也就是一个字节。每个单元有一个地址，是一个整数编码，可以表示为二进制整数。
程序中的变量和主存储器的存储单元相对应。变量的名字对应着存储单元的地址，变量内容对应着单元所存储的数据。


* 地址总线
地址总线 (Address Bus；又称：位址总线) 属于一种电脑总线 (一部份)，是由CPU 或有DMA 能力的单元，用来沟通这些单元想要存取(读取/写入)电脑内存元件/地方的实体位址。地址总线AB是专门用来传送地址的，由于地址只能从CPU传向外部存储器或输入输出端口，所以地址总线总是单向三态的，这与数据总线不同。地址总线的位数决定了CPU可直接寻址的内存空间大小

* 数据总线
数据总线DB（DataBus）用于传送数据信息。数据总线是双向三态形式的总线，即它既可以把CPU的数据传送到存储器或输入输出接口等其它部件，也可以将其它部件的数据传送到CPU。数据总线的位数是微型计算机的一个重要指标，通常与微处理的字长相一致。例如Intel8086微处理器字长16位，其数据总线宽度也是16位



* *和&
变量a 本质上代表一个存储单元。CPU通过该存储单元的地址访问该存储单元中的数据。所以a本来代表两个值：存储单元的地址和储单元中的数据。为了消除这种二义性，C语言规定a表示存储单元中的数据，&a表示存储单元的地址。
a存储单元中的数据可以是一个普通数值，也可以是另一个存储单元的地址，比如：a = &b; 语句就是将b的存储单元的地址存入a存储单元中。*a代表a中存储的地址对应的存储单元中的数据，也就是访问*a就等于访问b

&a表示a对应的存储单元的地址。 运算符&创建了一个指针
*a表示：首先，要求a对应的存储单元中的数据一定是另一个存储单元的地址。 *a获取指针中的数据


* 布尔运算
对于任意位向量，a^a = 0

* 原码 反码 补码
原码：就是一个数的二进制表示，是我们最熟悉的二进制有符号数的表示方式，正数的话符号位为0，负数为1。
例：15的原码就是0000 1111；-15的原码就是1000 1111。

反码：反码是基于原码的变动，有两种情况，如果是正数的反码，就跟原码相同。如果是负数的反码，则除了符号位，其他全部取反
例：15的反码就是0000 1111；-15的反码就是1111 0000。

补码：补码是基于反码的变动，有两种情况，如果是正数的补码，就跟原码反码都相同。如果是负数的补码，则在其反码的基础上，再加1
例：15的补码就是0000 1111；-15的补码就是1111 0001。


> 负数取模 (-2) mod 12 = 12-2=10
> 运算实例:
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补

我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.
计算十进制的表达式: 1-1=0
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原= [00000001]反 + [11111110]反 = [11111111]反 = [10000000]原 = -0
发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.
1-1 = 1 + (-1) = [00000001]原 + [10000001]原 = [00000001]补 + [11111111]补 = [00000000]补=[00000000]原

一个字节8位的有符号数表示范围是[-128, 127]



* CPU密集  IO密集型
CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程),而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。
CPU密集型任务配置尽可能少的线程数量
一般公式：（CPU核数+1）个线程的线程池

由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2。
CPU核数/ (1-阻塞系数)
阻塞系数在0.8~0.9之间
比如8核CPU：8/(1-0.9)=80个线程数